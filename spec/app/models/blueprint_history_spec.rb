# -*- coding: utf-8 -*-
# Copyright 2014 TIS Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
describe BlueprintHistory do
  include_context 'default_resources'

  let(:cloned_path) { File.expand_path("/tmp/archives/#{SecureRandom.uuid}") }
  let(:archives_directory) { File.expand_path('./tmp/archives/') }
  let(:archived_path) { File.join(archives_directory, "#{SecureRandom.uuid}.tar") }
  let(:patterns_directory) { File.join(archives_directory, SecureRandom.uuid) }

  before do
    allow_any_instance_of(Project).to receive(:create_preset_roles)

    @history = FactoryGirl.build(:blueprint_history, blueprint: blueprint)
    @history.version = 1

    allow(@history).to receive(:set_consul_secret_key)
    allow(@history).to receive(:set_ssh_private_key)
    allow(@history).to receive(:set_version)
  end

  describe '#save' do
    it 'create with valid parameters' do
      expect { @history.save! }.to change { BlueprintHistory.count }.by(1)
    end

    it 'call #set_consul_secret_key callback' do
      expect(@history).to receive(:set_consul_secret_key)
      @history.save!
    end

    it 'call #set_ssh_private_key callback' do
      expect(@history).to receive(:set_ssh_private_key)
      @history.save!
    end

    it 'call #set_version callback' do
      expect(@history).to receive(:set_version)
      @history.save!
    end

    it 'call #build_pattern_snapshots callback' do
      expect(@history).to receive(:build_pattern_snapshots)
      @history.save!
    end
  end

  describe '#destroy' do
    it 'delete blueprint history record' do
      @history.save!
      expect { @history.destroy }.to change { BlueprintHistory.count }.by(-1)
    end

    it 'delete all pattern history records' do
      @history.pattern_snapshots.delete_all
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot, blueprint_history: @history)
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot, blueprint_history: @history)

      expect(@history.pattern_snapshots.size).to eq(2)
      expect { @history.destroy }.to change { PatternSnapshot.count }.by(-2)
    end
  end

  describe '#valid?' do
    it 'returns true when valid model' do
      expect(@history.valid?).to be_truthy
    end

    it 'returns false when blueprint is unset' do
      @history.blueprint = nil
      expect(@history.valid?).to be_falsey
    end
  end

  describe '#set_consul_secret_key' do
    before do
      allow(@history).to receive(:set_consul_secret_key).and_call_original
      allow(SecureRandom).to receive(:base64).with(16).and_return('PDtYpNJ1wLvkSJw94SPoZQ==')
    end

    it 'create consul_secret_key if enabled ACL' do
      allow(CloudConductor::Config.consul.options).to receive(:acl).and_return(true)

      expect(@history.consul_secret_key).to be_nil
      @history.send(:set_consul_secret_key)
      expect(@history.consul_secret_key).to eq('PDtYpNJ1wLvkSJw94SPoZQ==')
    end
  end

  describe '#set_ssh_private_key' do
    before do
      allow(@history).to receive(:set_ssh_private_key).and_call_original
    end

    it 'create ssh private key and store to database' do
      expect(@history.ssh_private_key).to be_nil
      @history.send(:set_ssh_private_key)
      expect(@history.ssh_private_key).to match(/BEGIN RSA PRIVATE KEY.*END RSA PRIVATE KEY/m)
    end
  end

  describe '#ssh_public_key' do
    it 'return nil when ssh_private_key is nil' do
      @history.ssh_private_key = nil
      expect(@history.ssh_public_key).to be_nil
    end

    it 'return RSA public key which is generated by private key' do
      @history.ssh_private_key = <<-EOS
-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEA5Nma0b4nsjN5fM+gEcrPMtxwRGZEcZDo2IxeYTKNzGZu4brk
V2k6FIiBvqIn1rxGg8iQ1vVSfNUKxEf+ACUxeZH6zBQjHQWMd1HVPczFA3pAObJt
FDweQJqpAGt4Pdw0C4t8T1KdhBDCNdbfn9Etx/hmxv+9Pk78aTzXnM45P94XSaRw
k1G6gaJEVpue8o9+NuGCAbc1c1Z0SnY5FI+y0bjhkhz0v+yj5ak+qnhV8s5JIBsL
w1+yCmTU0T1/fywqvz66AtVE0ShZIChniH3B41mrWuV/gt0igrznUGrB8UCYckur
EmI2Q7x5C9s/TZooQjPWT3z7gXszukQCmqLzCQIDAQABAoIBAQCM0ZXhsFfu4JvG
AGCn8hsTWe+/NwqwsxGEhsNgneIBP5rFTeJKI1b44ZKswk0vZoUhfF4b17MdW16X
rxEN99T80KX5w/5jUlG/7lv//ivQ2v4AQtm6FNAswr5xoq/HqONho0An81c3t7Q5
uvG5/tZj8WcU1rMVTzckbqriM0epEw9w/Q3f4t/4gJfs+Fy4g1jX8uoJ7/dTiDCO
vskwgYyEYUVVkA+LHmEYybNmd5g87J7z7dUppVFUdwo1shnIFTb+mO4bokBGs131
XZfcg5v2sOnK+7O7QbHyn4tzUkRUHxM+FEavYWv/wJ65+jN136+YHRt0PlSc0j59
xrnkGPDdAoGBAPNY9HH28tK/CbRit6OwhnmsYgMMIfEM5TgLvk1m6IfxlP4rgBTE
duw2zsgb/FI7wmou+mHK9nAaQhFl4lnB9i/AG/EJ/mr3VHoKKWPLnOeqcNhd6Nwn
DhBGE6nUjF0dPNzLGgJsCPH0tSgcvtR/nDQc78kHvHekl7FIp13BzPYbAoGBAPC/
ru3QagCxbvXhcO4ugG3+bBvhCMNO7PjVuzc4CxfEqRyFqktNW3KbtXI1Agf9h7+h
KxFiYIQxz5lSBm9u3nIqGA8B0C4AbSYItmDOgqf+g5gfd3TqiXTlrR5PJeuQcVsq
0zGzgfStToNxLYKG7I6SIaD8WcC9fezZwEwIJJ2rAoGBANhsbsrEpGVGPi1N9qEA
KDkiVPD841rs6xeTaiaQtZHiC26Z5YmSyWl/vRw/t4KzX07shQZgahh9YfDzOgI1
/Ouu4arYBou/eEQpsXHt7pgi/8WOj8Dsgxd6G5bZUBSoIi8D+xfYWYRG7K7GEfoP
nC7E5YVW+gk2OysSwLcj21OtAoGAGz8GVCHHLWbnUOp/tmUK4efuYkVYkYoIJa1C
r+Am2TzHitPRzw3lMJZQtaksHq1hxJ0/24rPs4ZToV14HvpkMHV1HZWt8tbXg3tu
8IvOm6ahTAEbqt60SceIjSqV9w/01EWHe1N+fKt0fEm9xczxTr1ZEvgcTETl0H1g
VvqA8lsCgYEA6cM+mfXspLsIsJXVoXdi/26s5vg8buoCvnj1Hf0MuTDuAUlryFHe
Bb52jtf3WgTeuspuCHHNqwgpd7r6bTSmLuyprXgmJ72NvO5fKew8+QUue0ecZGSR
Q2YDsDEKKlGHNNAQKVgANuHKf7Q2exap2LsxveBjwMxpLlSbAiiIEXA=
-----END RSA PRIVATE KEY-----
      EOS

      expect(@history.ssh_public_key).to eq('AAAAB3NzaC1yc2EAAAADAQABAAABAQDk2ZrRvieyM3l8z6ARys8y3HBEZkRxkOjYjF5hMo3MZm7huuRXaToUiIG+oifWvEaDyJDW9VJ81QrER/4AJTF5kfrMFCMdBYx3UdU9zMUDekA5sm0UPB5AmqkAa3g93DQLi3xPUp2EEMI11t+f0S3H+GbG/70+TvxpPNeczjk/3hdJpHCTUbqBokRWm57yj3424YIBtzVzVnRKdjkUj7LRuOGSHPS/7KPlqT6qeFXyzkkgGwvDX7IKZNTRPX9/LCq/ProC1UTRKFkgKGeIfcHjWata5X+C3SKCvOdQasHxQJhyS6sSYjZDvHkL2z9NmihCM9ZPfPuBezO6RAKaovMJ')
    end
  end

  describe '#set_version' do
    before do
      allow(@history).to receive(:set_version).and_call_original
    end

    it 'set version 1 when previous history does not exist' do
      @history.version = nil
      @history.send(:set_version)
      expect(@history.version).to eq(1)
    end

    it 'set new version when previous history already exists' do
      @history.version = nil
      blueprint.histories << FactoryGirl.build(:blueprint_history)
      blueprint.histories << FactoryGirl.build(:blueprint_history)
      @history.send(:set_version)
      expect(@history.version).to eq(3)
    end
  end

  describe '#as_json' do
    it 'contains status' do
      allow(@history).to receive(:status).and_return(:CREATE_COMPLETE)
      hash = @history.as_json
      expect(hash['status']).to eq(:CREATE_COMPLETE)
    end

    it 'doesn\'t contain parameters' do
      hash = @history.as_json
      expect(hash['parameters']).to be_nil
    end

    it 'cloak sensitive attribute' do
      hash = @history.as_json
      expect(hash['encrypted_ssh_private_key']).to eq('********')
    end
  end

  describe '#status' do
    before do
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot, blueprint_history: @history)
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot, blueprint_history: @history)
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot, blueprint_history: @history)
      allow(@history.pattern_snapshots[0]).to receive(:status).and_return(:PROGRESS)
      allow(@history.pattern_snapshots[1]).to receive(:status).and_return(:PROGRESS)
      allow(@history.pattern_snapshots[2]).to receive(:status).and_return(:PROGRESS)
    end

    it 'return status that integrated status over all pattern_snapshots' do
      expect(@history.status).to eq(:PROGRESS)
    end

    it 'return :PROGRESS when least one pattern_snapshots has progress status' do
      allow(@history.pattern_snapshots[0]).to receive(:status).and_return(:CREATE_COMPLETE)

      expect(@history.status).to eq(:PROGRESS)
    end

    it 'return :CREATE_COMPLETE when all pattern_snapshots have CREATE_COMPLETE status' do
      allow(@history.pattern_snapshots[0]).to receive(:status).and_return(:CREATE_COMPLETE)
      allow(@history.pattern_snapshots[1]).to receive(:status).and_return(:CREATE_COMPLETE)
      allow(@history.pattern_snapshots[2]).to receive(:status).and_return(:CREATE_COMPLETE)

      expect(@history.status).to eq(:CREATE_COMPLETE)
    end

    it 'return error when least one image has error status' do
      allow(@history.pattern_snapshots[0]).to receive(:status).and_return(:CREATE_COMPLETE)
      allow(@history.pattern_snapshots[1]).to receive(:status).and_return(:PROGRESS)
      allow(@history.pattern_snapshots[2]).to receive(:status).and_return(:ERROR)

      expect(@history.status).to eq(:ERROR)
    end
  end

  describe '#providers' do
    before do
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot)
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot)
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot)
    end

    it 'return empty hash when pattern_snapshots are empty' do
      @history.pattern_snapshots.delete_all
      expect(@history.providers).to eq({})
    end

    it 'return usable providers on aws if all pattern_snapshots can use terraform' do
      @history.pattern_snapshots[0].providers = '{ "aws": ["terraform"] }'
      @history.pattern_snapshots[1].providers = '{ "aws": ["cloudformation", "terraform"] }'
      @history.pattern_snapshots[2].providers = '{ "aws": ["terraform", "dummy"] }'
      expect(@history.providers).to eq('aws' => %w(terraform))
    end

    it 'return usable providers on each cloud' do
      @history.pattern_snapshots[0].providers = '{ "aws": ["terraform"], "openstack": ["terraform", "heat"] }'
      @history.pattern_snapshots[1].providers = '{ "aws": ["terraform"], "openstack": ["terraform", "heat"] }'
      @history.pattern_snapshots[2].providers = '{ "aws": ["terraform", "dummy"], "openstack": ["terraform", "heat"] }'
      expect(@history.providers).to eq('aws' => %w(terraform), 'openstack' => %w(terraform heat))
    end

    it 'return empty provider on aws if pattern_snapshots have unique provider' do
      @history.pattern_snapshots[0].providers = '{ "aws": ["terraform"] }'
      @history.pattern_snapshots[1].providers = '{ "aws": ["cloudformation"] }'
      @history.pattern_snapshots[2].providers = '{ "aws": ["dummy"] }'
      expect(@history.providers).to eq({})
    end

    it 'return empty provider if some pattern_snapshots haven\'t provider' do
      @history.pattern_snapshots[0].providers = '{ "aws": ["terraform"] }'
      @history.pattern_snapshots[1].providers = '{ "aws": ["terraform"] }'
      @history.pattern_snapshots[2].providers = '{ "aws": ["terraform"], "openstack": ["heat"]}'
      expect(@history.providers).to eq('aws' => %w(terraform))
    end

    it 'return usable providers on aws if provider in metadata.yml as string instead of array' do
      @history.pattern_snapshots[0].providers = '{ "aws": "terraform" }'
      @history.pattern_snapshots[1].providers = '{ "aws": ["cloudformation", "terraform"] }'
      @history.pattern_snapshots[2].providers = '{ "aws": ["terraform", "dummy"] }'
      expect(@history.providers).to eq('aws' => %w(terraform))
    end

    it 'isn\'t effected by nil provider' do
      @history.pattern_snapshots[0].providers = '{ "aws": ["terraform"] }'
      @history.pattern_snapshots[1].providers = '{ "aws": ["cloudformation", "terraform"] }'
      @history.pattern_snapshots[2].providers = nil
      expect(@history.providers).to eq('aws' => %w(terraform))
    end
  end

  describe '#build_pattern_snapshots' do
    before do
      allow(@history).to receive(:build_pattern_snapshots).and_call_original
      allow(@history).to receive(:clone_repositories)
      allow(@history).to receive(:compress_patterns).and_return(archived_path)
      allow(@history).to receive(:providers).and_return('aws' => %w(terraform))
      allow(FileUtils).to receive(:rm_r)
      allow_any_instance_of(PatternSnapshot).to receive(:create_images)
      allow_any_instance_of(PatternSnapshot).to receive(:update_images)
      pattern1 = FactoryGirl.build(:pattern, :platform, project: project)
      pattern2 = FactoryGirl.build(:pattern, :optional, project: project)
      blueprint.blueprint_patterns << FactoryGirl.build(:blueprint_pattern, blueprint: blueprint, pattern: pattern1)
      blueprint.blueprint_patterns << FactoryGirl.build(:blueprint_pattern, blueprint: blueprint, pattern: pattern2)
    end

    it 'create pattern_snapshot from relation' do
      allow(@history).to receive(:providers).and_return('aws' => %w(terraform))
      @history.send(:build_pattern_snapshots)
      expect(@history.pattern_snapshots.size).to eq(2)
    end

    it 'will call #compress_patterns when block of clone_repositories call' do
      allow(@history).to receive(:clone_repositories) { |_, _, &block| block.call @history.pattern_snapshots }
      expect(@history).to receive(:compress_patterns).with(%r{/tmp/archives/[a-f0-9-]{36}}, archives_directory)
      @history.send(:build_pattern_snapshots)
    end

    it 'will call #create_images when block of clone_repositories call' do
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot)
      allow(@history).to receive(:clone_repositories) { |_, _, &block| block.call @history.pattern_snapshots }
      expect(@history.pattern_snapshots[0]).to receive(:create_images).with(%r{/tmp/archives/[a-f0-9-]{36}\.tar})
      @history.send(:build_pattern_snapshots)
    end

    it 'will call #update_images when block of create_iamges call' do
      @history.pattern_snapshots << FactoryGirl.create(:pattern_snapshot)
      results = { 'dummy' => {} }
      allow(@history).to receive(:clone_repositories) { |_, _, &block| block.call @history.pattern_snapshots }
      allow(@history.pattern_snapshots[0]).to receive(:create_images) { |_, &block| block.call results }
      expect(@history.pattern_snapshots[0]).to receive(:update_images).with(results)
      @history.send(:build_pattern_snapshots)
    end

    it 'raise error when patterns don\'t have usable providers on any cloud' do
      allow(@history).to receive(:providers).and_return({})
      expect { @history.send(:build_pattern_snapshots) }.to raise_error('Patterns don\'t have usable providers on any cloud')
    end
  end
end
